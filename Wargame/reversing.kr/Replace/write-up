05. Replace
  - 문제 정보
  01) 문제 실행 시 윈도우 입력 폼이 하나 뜨고 아무런 입력을 못하는 상태로 Wrong!으로 문자열만 나오는 상태
  02) 정상적으로 입력 가능하도록 조작필요한 상태로 추정
  03) 프로그램 패치에 중점두고 작업 진행
  
  - 풀이 절차
  01) PEiD를 이용하여 문제의 환경 확인 결과 Visual C++ 6.0 기반 소프트웨어인 것 확인.
  02) mov dword_4084D0, eax -> eax = 0x4F9 / dword_4084D0 = 0x4F9
      call sub_40466F -> sub_40466F 함수 실행
      - sub_40466F Instruction 코드
      1) call loc_40467A -> eip를 0040467A로 이동
      2) mov dword_406016, 619060EBh -> 00406016 자리에 0x619060EB 입력
          -> 삽입한 위치 근처에 Correct! 메시지 호출 함수 있음
      3) call $+5 -> 현재 위치인 00404684에서 +5 한 값인 00404689 위치 이동
      4) inc dword_4084D0 -> dword_4084D0 = <입력값> + 1
      5) retn이 실행되면서 현재 eip 주소에서 4만큼 빠져나가며 한번더 실행해서 <입력값> + 2
        -> 4, 5를 합치면 004084D0 = <입력값> +  2
      6) 00404674의 해석 안되는 코드는 아래와 같은 내용
        - add dword ptr [004084D0], 601605CAh : 004084D0 위치에 601605C7만큼 더하기
      7) 그런 다음 4, 5 과정 다시 호출하여 값 더하기
       => 1 ~ 7 까지의 절차대로면 004084D0 = <입력값> + 2 + 0x601605C7 + 2 = 0x601605CA + <입력값>
      8) 그다음 mov ptr [eax], 90h / retn을 실행할때 eax에 있는 값의 위치가 참조할 수 있는 위치면 해당 명령어가 실행되면서 NOP 코드가 덮어씌워짐
       => 여기에서 데이터가 수정되는 절차가 총 2번 실행되면서 NOP 코드로 인해 분기가 변경되어 Correct!로 메시지가 변경된다.
          따라서 7)까지의 결과로 EAX에 저장되는 값이 0x401071로 결정되면 해당 위치에 있는 JMP(EB 11) Instruction 코드를 1바이트씩 2번 NOP로 수정하는 절차를 거치면 분기 수정 가능.
  - 주의 사항
    : NOP 코드 분기가 Windows 10에서 정확하게 동작하지 않는 현상이 발생함.
      정확한 실습을 위해서는 하위 버전의 윈도우에서 이를 실습하는 것을 추천함.
